<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>å›¾ç‰‡é²æ£’æ‰“æ ‡ / è¯»å– / æµ‹è¯•ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</title>
<style>
:root{--bg:#f7fbff;--card:#fff;--accent:#0b63ff;--muted:#6b7c93}
body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Arial;background:var(--bg);margin:0;padding:14px;color:#0b2440}
.wrap{max-width:640px;margin:0 auto}
h1{text-align:center;color:var(--accent);font-size:18px;margin-bottom:8px}
.card{background:var(--card);border-radius:12px;padding:12px;margin:10px 0;border:1px solid #e6f2ff;box-shadow:0 6px 18px rgba(11,37,80,0.04)}
input[type=file],input[type=text],select,button{width:100%;padding:12px;border-radius:10px;border:1px solid #d7eaff;margin:8px 0;box-sizing:border-box;font-size:15px}
button{background:var(--accent);color:#fff;border:none;font-weight:600}
small.note{display:block;color:var(--muted);margin-top:6px;font-size:13px}
#preview,#testPreview{width:100%;border-radius:8px;margin-top:8px;object-fit:contain;max-height:360px}
#log{white-space:pre-wrap;font-size:13px;color:#0b2440;margin-top:8px}
.report{margin-top:8px;padding:10px;border-radius:8px;background:#f0f6ff;border:1px solid:#e0efff}
.row{display:flex;gap:8px}
.col{flex:1}
.progress{height:8px;background:#e9f1ff;border-radius:8px;overflow:hidden;margin-top:6px}
.progress-bar{height:100%;width:0;background:linear-gradient(90deg,var(--accent),#3aa0ff)}
.tiny{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
<h1>ğŸ“Œ å›¾ç‰‡é²æ£’æ‰“æ ‡ / è¯»å– / æµ‹è¯•ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</h1>

<div class="card">
  <strong>è¯´æ˜</strong>
  <p class="tiny">1) æ‰“æ ‡å›¾ç‰‡ â†’ åµŒå…¥å”¯ä¸€æ–‡æœ¬ä¿¡æ¯<br>
  2) è¯»å–æ ‡è®° â†’ æå–åµŒå…¥æ–‡æœ¬<br>
  3) é²æ£’æ€§æµ‹è¯• â†’ è£å‰ª/æ¨¡ç³Š/äº®åº¦/å¯¹æ¯”åº¦å˜åŒ–<br>
  ä¼˜åŒ–ï¼šå¼‚æ­¥æ‰¹é‡ DCT/IDCT + UIä¸å¡æ­» + è‡ªåŠ¨ä¿å­˜</p>
</div>

<!-- æ‰“æ ‡æ¨¡å— -->
<div class="card">
  <strong>1ï¸âƒ£ æ‰“æ ‡å›¾ç‰‡</strong>
  <input id="fileIn" type="file" accept="image/*">
  <input id="textIn" type="text" placeholder="è¾“å…¥æ ‡è®°æ–‡æœ¬ï¼ˆâ‰¤32å­—èŠ‚ï¼‰">
  <div class="row">
    <div class="col">
      <label>å†—ä½™</label>
      <select id="redundancy"><option>12</option><option selected>8</option><option>6</option><option>4</option></select>
    </div>
    <div class="col">
      <label>å¼ºåº¦</label>
      <select id="delta"><option>4</option><option selected>6</option><option>8</option></select>
    </div>
  </div>
  <input id="seed" type="text" placeholder="éšæœºç§å­ï¼ˆç•™ç©ºé»˜è®¤æ–‡æœ¬å“ˆå¸Œï¼‰" />
  <button id="embedBtn">æ‰“æ ‡å¹¶è‡ªåŠ¨ä¿å­˜</button>
  <div class="progress"><div id="embedProgress" class="progress-bar"></div></div>
  <img id="preview" src="" alt="">
  <div id="log" aria-live="polite"></div>
</div>

<!-- è¯»å–æ¨¡å— -->
<div class="card">
  <strong>2ï¸âƒ£ è¯»å–æ ‡è®°</strong>
  <input id="fileRead" type="file" accept="image/*">
  <label>ç¡®ä¿ä½¿ç”¨ç›¸åŒ å†—ä½™ / å¼ºåº¦ / éšæœºç§å­</label>
  <button id="readBtn">è¯»å–å›¾ç‰‡ä¸­çš„æ ‡è®°</button>
  <div id="readOut" class="report"></div>
  <div class="tiny">æç¤ºï¼šè£å‰ª/æ¨¡ç³Š/é‡ç»˜è¿‡å¤šå¯èƒ½é™ä½è¯»å–æˆåŠŸç‡</div>
</div>

<!-- é²æ£’æ€§æµ‹è¯•æ¨¡å— -->
<div class="card">
  <strong>3ï¸âƒ£ é²æ£’æ€§æµ‹è¯•</strong>
  <label>é€‰æ‹©å·²æ‰“æ ‡å›¾ç‰‡è¿›è¡Œæµ‹è¯•</label>
  <input id="fileTest" type="file" accept="image/*">
  <div class="row">
    <div class="col"><button id="cropBtn">éšæœºè£å‰ª</button></div>
    <div class="col"><button id="blurBtn">è½»åº¦æ¨¡ç³Š</button></div>
    <div class="col"><button id="brightBtn">äº®åº¦/å¯¹æ¯”åº¦</button></div>
  </div>
  <img id="testPreview" src="" alt="">
  <button id="readTestBtn">è¯»å–å¤„ç†åæ ‡è®°</button>
  <div id="readTestOut" class="report"></div>
  <div class="tiny">æç¤ºï¼šå¯å¤šæ¬¡æ“ä½œï¼Œæµ‹è¯•æ ‡è®°åœ¨ä¸åŒå˜å½¢ä¸‹çš„æ¢å¤æƒ…å†µ</div>
</div>
</div>

<script>
/* ================== DCT 8x8 ================== */
const N=8;
const C=Array.from({length:N},()=>new Array(N));
for(let u=0;u<N;u++)for(let v=0;v<N;v++)C[u][v]=(u===0?1/Math.sqrt(2):1)*(v===0?1/Math.sqrt(2):1);
const PAIR=[[2,1],[1,2]];

/* ================== YUVè½¬æ¢ ================== */
function rgbaToYUV(imgd,w,h){
    const d=imgd.data;
    const Y=Array.from({length:h},()=>new Array(w).fill(0));
    const U=Array.from({length:h},()=>new Array(w).fill(0));
    const V=Array.from({length:h},()=>new Array(w).fill(0));
    let idx=0;
    for(let i=0;i<h;i++)for(let j=0;j<w;j++){
        const r=d[idx++],g=d[idx++],b=d[idx++],a=d[idx++];
        Y[i][j]=0.299*r+0.587*g+0.114*b;
        U[i][j]=-0.169*r-0.331*g+0.5*b;
        V[i][j]=0.5*r-0.419*g-0.081*b;
    }
    return {Y,U,V};
}
function applyYUVToImageData(Y,U,V,imgd,w,h){
    const d=imgd.data;let idx=0;
    for(let i=0;i<h;i++)for(let j=0;j<w;j++){
        const y=Y[i][j],u=U[i][j],v=V[i][j];
        d[idx++]=Math.min(255,Math.max(0,Math.round(y+1.402*v)));
        d[idx++]=Math.min(255,Math.max(0,Math.round(y-0.344136*u-0.714136*v)));
        d[idx++]=Math.min(255,Math.max(0,Math.round(y+1.772*u)));
        d[idx++]=255;
    }
}

/* ================== bits â†” bytes ================== */
const SIGN="TAGR";
function buildBits(msg){
    const encoder=new TextEncoder();
    const payload=encoder.encode(msg);
    const len=payload.length;
    const header=new Uint8Array(4+2+len);
    for(let i=0;i<4;i++)header[i]=SIGN.charCodeAt(i);
    header[4]=(len>>8)&0xff;header[5]=len&0xff;
    header.set(payload,6);
    const bits=[];
    for(let i=0;i<header.length;i++)for(let b=7;b>=0;b--)bits.push((header[i]>>b)&1);
    return bits;
}
function bitsToBytes(bits){
    const bytes=[];
    for(let i=0;i+7<bits.length;i+=8){
        let v=0;
        for(let b=0;b<8;b++)v=(v<<1)|bits[i+b];
        bytes.push(v);
    }
    return bytes;
}

/* ================== PRNG ================== */
function xorshift32(seed){let x=seed>>>0;return function(){x^=x<<13;x>>>0;x^=x>>>17;x>>>0;x^=x<<5;x>>>0;return x;}};
function seedFromString(s){let h=2166136261;for(let i=0;i<s.length;i++){h^=s.charCodeAt(i);h=Math.imul(h,16777619);}return h>>>0;}
function generateBlockOrder(blocksAcross,blocksDown,seedStr){
    const n=blocksAcross*blocksDown;
    const seed=seedFromString(seedStr||"default_seed");
    const rnd=xorshift32(seed);
    const arr=new Array(n);
    for(let i=0;i<n;i++)arr[i]=i;
    for(let i=n-1;i>0;i--){
        const r=rnd()%(i+1);
        const t=arr[i];arr[i]=arr[r];arr[r]=t;
    }
    return arr;
}

/* ================== å¼‚æ­¥åµŒå…¥ ================== */
async function embedBitsToYAsync(Y, w, h, bits, redundancy, delta, blockOrder, progressCallback) {
    const blocksAcross = Math.floor(w/8), blocksDown = Math.floor(h/8);
    const totalBlocks = blocksAcross*blocksDown;
    const required = bits.length*redundancy;
    if(required>totalBlocks)return {ok:false,reason:`ç©ºé—´ä¸è¶³ï¼šéœ€ ${required} å—ï¼Œç°æœ‰ ${totalBlocks} å—`};

    // é¢„è®¡ç®— cos è¡¨
    const cosTable = Array.from({length:8}, (_,i)=>Array.from({length:8},(_,j)=>Math.cos((2*i+1)*j*Math.PI/16)));

    // åˆ†å— DCT
    const blocksDCT = [];
    for(let bx=0; bx<blocksAcross; bx++){
        for(let by=0; by<blocksDown; by++){
            const block = Array.from({length:8},()=>new Array(8));
            for(let x=0;x<8;x++) for(let y=0;y<8;y++) block[x][y] = Y[bx*8+x][by*8+y]-128;
            const F = Array.from({length:8},()=>new Array(8).fill(0));
            for(let u=0;u<8;u++)for(let v=0;v<8;v++){
                let s=0;for(let x=0;x<8;x++)for(let y=0;y<8;y++)s+=block[x][y]*cosTable[x][u]*cosTable[y][v];
                F[u][v]=0.25*(u===0?1/Math.sqrt(2):1)*(v===0?1/Math.sqrt(2):1)*s;
            }
            blocksDCT.push(F);
        }
    }

    // åµŒå…¥ bits
    let used=0;
    const batchSize=64;
    for(let i=0;i<bits.length;i++){
        for(let r=0;r<redundancy;r++){
            const blockIdx=blockOrder[used++];
            const F=blocksDCT[blockIdx];
            const [u1,v1]=PAIR[0],[u2,v2]=PAIR[1];
            let a=F[u1][v1],b=F[u2][v2];
            const bit=bits[i];
            if(bit===1){if(!(a>b+delta))F[u1][v1]+=(b+delta-a+0.6);}
            else{if(!(b>a+delta))F[u2][v2]+=(a+delta-b+0.6);}
        }
        if(progressCallback)progressCallback(Math.round((i+1)/bits.length*100));
        if(i%batchSize===0)await new Promise(r=>setTimeout(r,0));
    }

    // IDCT å›å†™
    used=0;
    for(let bx=0;bx<blocksAcross;bx++){
        for(let by=0;by<blocksDown;by++){
            const F=blocksDCT[bx*blocksDown+by];
            const block=Array.from({length:8},()=>new Array(8).fill(0));
            for(let x=0;x<8;x++){
                for(let y=0;y<8;y++){
                    let s=0;
                    for(let u=0;u<8;u++)for(let v=0;v<8;v++)s+=(u===0?1/Math.sqrt(2):1)*(v===0?1/Math.sqrt(2):1)*F[u][v]*cosTable[x][u]*cosTable[y][v];
                    block[x][y]=0.25*s;
                }
            }
            for(let x=0;x<8;x++)for(let y=0;y<8;y++)Y[bx*8+x][by*8+y]=Math.min(255,Math.max(0,block[x][y]+128));
        }
    }

    return {ok:true};
}

/* ================== UI wiring ================== */
const fileIn=document.getElementById('fileIn'),preview=document.getElementById('preview'),progressBar=document.getElementById('embedProgress'),logDiv=document.getElementById('log');
let workCanvas=document.createElement('canvas'),workCtx=workCanvas.getContext('2d'),origName='image';
function log(msg){logDiv.textContent=(new Date()).toLocaleTimeString()+'  '+msg+'\n'+logDiv.textContent;}
fileIn.addEventListener('change',e=>{const f=e.target.files[0];if(!f)return;origName=f.name.replace(/\.[^/.]+$/,'');const url=URL.createObjectURL(f);const img=new Image();img.onload=()=>{workCanvas.width=img.naturalWidth;workCanvas.height=img.naturalHeight;workCtx.drawImage(img,0,0);preview.src=workCanvas.toDataURL('image/png');log(`åŠ è½½ ${f.name} å°ºå¯¸ ${img.naturalWidth}x${img.naturalHeight}`);URL.revokeObjectURL(url);};img.src=url;});

document.getElementById('embedBtn').addEventListener('click', async () => {
    const text = document.getElementById('textIn').value.trim();
    if(!text){ alert('è¯·è¾“å…¥æ ‡è®°æ–‡æœ¬'); return; }
    const redundancy = parseInt(document.getElementById('redundancy').value,10);
    const delta = parseFloat(document.getElementById('delta').value);
    const seedInput = document.getElementById('seed').value.trim();
    const seedStr = seedInput || text;
    const w=workCanvas.width, h=workCanvas.height;
    if(!w||!h){ alert('è¯·å…ˆé€‰æ‹©å›¾ç‰‡'); return; }
    const imgd = workCtx.getImageData(0,0,w,h);
    const {Y,U,V} = rgbaToYUV(imgd,w,h);
    const bits = buildBits(text);
    const blockOrder = generateBlockOrder(Math.floor(w/8),Math.floor(h/8),seedStr);
    progressBar.style.width='0%';
    log(`å‡†å¤‡åµŒå…¥ï¼šæ–‡æœ¬ ${text.length} å­—èŠ‚ bits=${bits.length} å†—ä½™=${redundancy} å¼ºåº¦=${delta} seed=${seedStr}`);
    const res = await embedBitsToYAsync(Y,w,h,bits,redundancy,delta,blockOrder,p=>{progressBar.style.width=p+'%';});
    if(!res.ok){ alert(res.reason); log(res.reason); return; }
    progressBar.style.width='100%';
    applyYUVToImageData(Y,U,V,imgd,w,h);
    workCtx.putImageData(imgd,0,0);
    preview.src = workCanvas.toDataURL('image/png');
    const a = document.createElement('a');
    a.href = workCanvas.toDataURL('image/png');
    a.download = `${origName}_tagged.png`;
    a.click();
    log('åµŒå…¥å®Œæˆå¹¶ä¸‹è½½ï¼š'+`${origName}_tagged.png`);
    alert('åµŒå…¥å®Œæˆå¹¶å·²ä¿å­˜ï¼ˆæ‰‹æœºè¯·é•¿æŒ‰å›¾ç‰‡ä¿å­˜ï¼‰');
});

/* è¯»å–æ¨¡å— & é²æ£’æ€§æµ‹è¯•ä¿æŒåŸæœ‰é€»è¾‘å³å¯ï¼ˆå¯å‚è€ƒä½ åŸæ¥çš„ä»£ç ï¼‰ */
</script>
</body>
</html>